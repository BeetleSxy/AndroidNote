# Java

## Java 对象生命周期

Java 对象在 JVM 上运行有 7 个阶段：

- Created
- InUse
- Invisible
- Unreachable
- Collected
- Finalized
- Deallocated

### Created(创建)

1. 为对象分配存储空间
2. 构造对象
3. 从超类到子类对 static 成员进行初始化，类的 static 成员的初始化在 ClassLoader 加载该类时进行。
4. 超类成员变量按顺序初始化，递归调用超类的构造方法。
5. 子类成员变量按顺序初始化，一旦对象被创建，子类构造方法就调用该对象并为某些变量赋值。

### InUse（应用）

此对象至少被一个强引用持有。

### Invisible（不可见）

当对象处于不可见阶段时，说明程序本身不在持有该对象的任何强引用，虽然该对象仍然是存在的。简单的例子就是**程序执行已经超出了该对象的作用域**。但是该对象**仍然可能被虚拟机下的某些已经装载的静态变量线程或 JNI 等强引用持有**，这些特殊的强引用称为 “GC Root”。被这些 GC Root 强引用的对象会导致该对象的内存泄漏，因而无法被 GC 回收。

### Unreachable（不可达）

改对象不在被任何强应用持有。

### Collected（收集）

当 GC 已经对该对象的内存空间重新分配做好准备时，对象进入收集阶段，如果该对象重写了 finalize() 方法，则执行它。

### Finalized（终结）

等待垃圾回收器回收该对象空间。

### Deallocated（对象空间重新分配）

GC 该对象所占用的内存空间进行回收或者在分配，则该对象彻底消失。

###  **注意**

1. 不需要使用该对象时，即时置空。
2. 访问本地变量优于访问类中的变量。

## Java 内存分配模型

JVM 将内存划分为几块：

1. 方法区：存储类信息、常量、静态变量等。=>所有线程共享
2. 虚拟机栈：存储局部变量表，操作数栈等。
3. 本地方法栈：不同与虚拟机栈为 java 方法服务，它是为 Native 方法服务等。
4. 堆：内存最大的区域，每一个对象实际分配内存都在堆上进行分配的，而在虚拟机栈中分配的只是引用，这些引用会指向堆中真正存储的对象。此外，堆也是垃圾回收器（GC）所主要作用的区域，并且，内存泄漏也都是发生在这个区域。=>所有线程共享
5. 程序计数器：存储当前线程执行目标方法执行到了第几行。

## Java 内存回收算法

#### 1. 标记 - 清除算法

#### 2. 复制算法

#### 3. 标记 - 整理算法

#### 4. 分代收集算法（大多数虚拟机厂商所选用的算法）

# Android 

## Android 内存分配模型

## Android 内存回收机制

