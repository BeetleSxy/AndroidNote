#  JVM 内存模型和内存区域？

## 内存结构

### 程序计数器

程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为 “线程私有” 的内存。 如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Natvie 方法，这个计数器值则为空（Undefined）。 此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

### Java 虚拟机栈

虚拟机栈描述的是 Java 方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。 在 Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。

### 堆内存

对于大多数应用来说，Java 堆（Java Heap）是 Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。（栈上分配、标量替换会导致对象不分配在堆内存中） Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做 “GC 堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等。 根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过 - Xmx 和 - Xms 控制）。 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。

### 方法区

方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。 根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。

## 内存分配策略

### 对象优先在 Eden 分配

**大多数情况下，对象在新生代 Eden 去中分配，（注：java 堆中的新生代可分为 Eden 区和两个 Survivor 区），当 Eden 区中没有足够的空间进行分配时，虚拟机将发起一次 Minor GC。**

> Minor GC 和 Full GC 的区别
>
> - 新生代 GC (Minor GC)：指的是发生在新生代中的垃圾收集动作，java 对象的创建和回收非常频繁，所以 Mnior GC 非常频繁，一般回收速度也比较快。
> - 老年代 GC (Major GC/Full FC): 指发生在老年代中的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 慢 10 倍以上。

### 大对象直接进入老年代

大对象是指，需要大量连续内存空间的 java 对象（写程序的时候应该避免 “短命大对象”），经常出现大对象，容易导致内存还有不少空间时，就提前触发垃圾收集以获取足够的连续空间来分给他们。 虚拟机提供 - XX:PretenureSizeThreshold 参数，令大于这个设置值的对象直接进入老年代，这么做为目的是为了避免在 Eden 以及两个 Survivor 区之间发生大量的内存复制（新生代的垃圾收集算法采用复制算法）。

### 长期存活的对象将进入老年代

虚拟机给每个对象定义一个对象年龄（Age）的计数器，如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象年龄设为 1. 其在 Survivor 中没经历一次 Minior GC，Age 就加 1，当其 Age 增加到一定程度（默认 15 岁），就将其晋升到老年代。年龄阈值可以通过参数 - XX:MxTenuringThreshold 设置。

## 动态对象的年龄判定

为了能更好的适应不同程序的内存状况，虚拟机不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，**如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代。**

## 空间分配担保

在发生 Minor GC 之前，虚拟机会先检查老年代中最大可用连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将尝试进行一次 Minor GC。如果小于或者 HandlePromotionFailure 设置为不允许，那这时就改为一次 Full GC。 分配担保解释：新生代使用复制算法完成垃圾收集，为了节约内存 Survivor 的设置的比较小，当 Minor GC 后如果还有大量对象存活，超过了一个 Survivor 的内存空间，这时就需要老年代进行分配担保，把 Survivor 中无法容纳的对象直接进入老年代。若虚拟机检查老年代中最大可用连续空间大于新生代所有对象总空间那么就能保证不需要发生 Full GC，因为老年代的内存空间够用。反之，如果老年代中最大可用连续空间小于新生代所有对象总空间就需要在尝试 Minor GC 失败后进行 Full Gc 或者直接 Full GC。

# JVM加载class文件的原理机制

JVM加载class文件的原理机制 JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：

1. 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类。
2. 如果类中存在初始化语句，就依次执行这些初始化语句。
3. 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。

从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。 JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：

1.  Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）。
2.  Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap。
3.  System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性 java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。


#  String a = "a"+"b"+"c" 在内存中创建几个对象？
**1个String对象**

"a"+"b"+"c"在编译期已经常量折叠为"abc"

变量a获得是"abc"。
