# 线程和进程的区别？

## 进程
进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。

## 线程
线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。

## 线程和进程各自有什么区别和优劣呢？
- 进程是资源分配的最小单位，线程是程序执行的最小单位。
- 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
- 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
- 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

# 说说你对线程池的理解?

## 使用线程池的原因：

1. 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
2. 可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，(每个线程需要大约 1MB 内存，线程开的越多，消耗的内存也就越大)。

## 线程池的分类：

1. 线程池都是通过 Executors 来创建的。
2. newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
3. newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
4. newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
5. newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序执行。

## 线程数解析：

1. corePoolSize： 线程池维护线程的最少数量。
2. maximumPoolSize：线程池维护线程的最大数量。
3. keepAliveTime： 线程池维护线程所允许的空闲时间。
4. workQueue： 线程池所使用的缓冲队列。
5. handler： 线程池对拒绝任务的处理策略。

## 创建规则： 一个任务通过 execute (Runnable) 方法欲添加到线程池时：

1. 如果此时线程池中的数量小于 corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。
2. 如果此时线程池中的数量等于 corePoolSize，但是缓冲队列 workQueue 未满，那么任务被放入缓冲队列。
3. 如果此时线程池中的数量大于 corePoolSize，缓冲队列 workQueue 满，并且线程池中的数量小于 maximumPoolSize，建新的线程来处理被添加的任务。
4. 如果此时线程池中的数量大于 corePoolSize，缓冲队列 workQueue 满，并且线程池中的数量等于 maximumPoolSize，那么通过 handler 所指定的策略来处理此任务。也就是：处理任务的优先级为：核心线程 corePoolSize、任务队列 workQueue、最大线程 maximumPoolSize，如果三者都满了，使用 handler 处理被拒绝的任务。
5. 当线程池中的线程数量大于 corePoolSize 时，如果某线程空闲时间超过 keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。

## 终止和关闭线程池： hreadPoolExecutor 提供了两个方法，用于线程池的关闭，分别是 shutdown () 和 shutdownNow ()，其中：

1. Shutdown ()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。
2. ShutdownNow ()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。

# 什么是深拷贝和浅拷贝？

## 为什么要克隆？

克隆的对象可能包含一些已经修改过的属性，保留着你想克隆对象的值，而 new 出来的对象的属性全是一个新的对象，对应的属性没有值，所以我们还要重新给这个对象赋值。即当需要一个新的对象来保存当前对象的 “状态” 就靠 clone 方法了。 

## 如何实现克隆？

1. 对象的类实现 Cloneable 接口； 
2. 覆盖 Object 类的 clone () 方法 （覆盖 clone () 方法，访问修饰符设为 public，默认是 protected）； 
3. 在 clone () 方法中调用 super.clone ()；

## 浅克隆 (ShallowClone) 和深克隆 (DeepClone)

- 浅克隆：是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。 

- 深克隆：不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。举例

# 死锁与活锁的区别，死锁与饥饿的区别？
## 死锁
是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

### 产生死锁的必要条件：

1. 互斥条件：所谓互斥就是进程在某一时间内独占资源。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

## 活锁
任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。

**活锁和死锁的区别**在于，处于活锁的实体是在不断的改变状态，所谓的 “活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。

## 饥饿
一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。

### Java 中导致饥饿的原因：

1. 高优先级线程吞噬所有的低优先级线程的 CPU 时间。
2. 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。
3. 线程在等待一个本身也处于永久等待完成的对象 (比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。